import os, glob, numpy, time
import matplotlib.pyplot as plt
from skimage.transform import resize
os.chdir('E:\\Malware-Datasets\\malimg_paper_dataset_imgs\\')  # the parent folder with sub-folders

list_fams = [ name for name in os.listdir(os.getcwd()) if os.path.isdir(os.path.join(os.getcwd(), name)) ]
#os.listdir(os.getcwd())  # vector of strings with family names

no_imgs = []  # No. of samples per family

for i in range(len(list_fams)):
    os.chdir(list_fams[i])
    len1 = len(glob.glob('*.png'))  # assuming the images are stored as 'png'
    no_imgs.append(len1)
    os.chdir('..')

total = sum(no_imgs)  # total number of all samples
y = numpy.zeros(total)  # label vector

temp1 = numpy.zeros(len(no_imgs) + 1)
temp1[1:len(temp1)] = no_imgs
temp2 = int(temp1[0]);  # now temp2 is [0 no_imgs]

for jj in range(len(no_imgs)): 
    temp3 = temp2 + int(temp1[jj + 1])
    for ii in range(temp2, temp3): 
        y[ii] = jj
    temp2 = temp2 + int(temp1[jj + 1])

from PIL import Image
 
X = [ ] 
cnt = 0
for i in range(len(list_fams)):
    os.chdir(list_fams[i])
    img_list = glob.glob('*.png') # Getting only 'png' files in a folder
    for j in range(len(img_list)):
        img = plt.imread(img_list[j])
        X.append(img)
        cnt = cnt + 1 
    os.chdir('..')
X = numpy.array(X)

image = []
for i in range(0,X.shape[0]):
    a = resize(X[i], preserve_range=True, output_shape=(64,64,1)).astype('float32')      # reshaping to 224*224*3
    image.append(a)
X = numpy.array(image)
0 
output_dir= '../output'
if not os.path.exists(output_dir):
    os.makedirs(output_dir)
os.chdir(output_dir) # some folder for storing


import random
from sklearn.model_selection import StratifiedKFold
from sklearn.utils import shuffle 

n_samples, n_features = X.shape[0], (X.shape[1], X.shape[2]) 
p = range(n_samples) # an index array, 0:n_samples
random.seed(random.random()) 
random.shuffle(p) # the index array is now shuffled

X, y = X[p], y[p] # both the arrays are now shuffled


from keras.applications.vgg16 import preprocess_input
X = preprocess_input(X, mode='tf')     


from sklearn.model_selection import train_test_split
from keras.utils import np_utils
dummy_y = np_utils.to_categorical(y)   
X_train, X_valid, y_train, y_valid = train_test_split(X, dummy_y, test_size=0.3, random_state=42)    # preparing the validation set

from keras.models import Sequential
from keras.applications.vgg16 import VGG16
from keras.layers import Dense, InputLayer, Dropout
#We will now load the VGG16 pretrained model and store it as base_model:
base_model = VGG16(weights='imagenet', include_top=False, input_shape=(64, 64, 1))    # include_top=False to remove the top layer
#We will make predictions using this model for X_train and X_valid, 
#get the features, and then use those features to retrain the model.



import keras
from keras.models import Sequential, Input, Model
from keras.layers import Dense, Dropout, Flatten
from keras.layers import Conv2D, MaxPooling2D
from keras.layers.normalization import BatchNormalization
from keras.layers.advanced_activations import LeakyReLU

Malware_Model = Sequential()
#Malware_Model.add(InputLayer((size_shape,)))    # input layer
Malware_Model.add(base_model)
Malware_Model.add(Flatten())
Malware_Model.add(Dense(units=1024, activation='sigmoid')) # hidden layer
Malware_Model.add(Dense(len(list_fams), activation='sigmoid')) 

Malware_Model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])

# Training
tic = time.time()
Malware_Model.fit(X_train,y_train, epochs=20, batch_size=16) 
toc = time.time()
print ("training time= ", toc-tic) # roughly 2.5 secs

# Testing
y_predict = []
tic = time.time()
y_predict = Malware_Model.predict(X_valid) # output is labels and not indices
toc = time.time()
print ("testing time = ", toc-tic) # roughly 0.3 secs

conf_mat = numpy.zeros((len(no_imgs),len(no_imgs))) # Initializing the Confusion Matrix
# Compute confusion matrix
from sklearn.metrics import confusion_matrix
cm = []
y_predict = numpy.argmax(y_predict, axis=1)
y_valid = numpy.argmax(y_valid, axis=1)
cm = confusion_matrix(y_valid,y_predict)
conf_mat = conf_mat + cm 
 
conf_mat = conf_mat.T # since rows and  cols are interchanged
avg_acc = numpy.trace(conf_mat)/sum(no_imgs)
conf_mat_norm = conf_mat/no_imgs # Normalizing the confusion matrix


# Viewing the confusion matrix
import matplotlib.pyplot as plt
plt.imshow(conf_mat_norm, interpolation='nearest')
plt.title('Confusion matrix')
plt.colorbar()
plt.savefig('confusion_matrix_ANN.png', dpi=1000)
plt.show()

conf_mat2 = numpy.around(conf_mat_norm,decimals=2) # rounding to display in figure
plt.imshow(conf_mat2,interpolation='nearest')
for x in xrange(len(list_fams)):
  for y in xrange(len(list_fams)):
    plt.annotate(str(conf_mat2[x][y]),xy=(y,x),ha='center',va='center')

plt.xticks(range(len(list_fams)),list_fams,rotation=90,fontsize=11)
plt.yticks(range(len(list_fams)),list_fams,fontsize=11)
plt.title('Confusion matrix')
plt.colorbar()
plt.savefig('confusion_matrix2_ANN.png', dpi=1000)
plt.show()

